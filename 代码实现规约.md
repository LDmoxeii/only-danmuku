# 代码实现规约（only-danmuku）

本规约结合当前代码与生成体系（cap4k + GenDesign）进行细化，覆盖项目结构、API、命令/查询、防腐层 Client、聚合与领域事件等实践指引。

—

## 项目结构与职责

- adapter 层（对外适配）：
  - 职责：对接 HTTP/Web 层，将入参转换为应用层命令/查询；承载对外的兼容接口；承载“防腐层 Client 的 Handler”（对外部系统/SDK 的适配）。
  - 典型位置：`only-danmuku-adapter/src/main/kotlin/.../portal/api`（Controller）、`.../application/queries`（QueryHandler）、`.../application/distributed/clients`（ClientHandler）。
  - 仅做编排与入参校验，禁止直接操作聚合或编写业务分支。

- application 层（用例编排）：
  - 职责：定义命令（Command）与查询（Query）契约，组织用例流程；持有事务边界；通过 Mediator 访问仓储/工厂、落盘变更。
  - 典型位置：`only-danmuku-application/src/main/kotlin/.../commands|queries|subscribers|distributed/clients`（Client 契约）。
  - 命令修改聚合，查询读取读模型；命令不依赖查询、查询不依赖仓储。

- domain 层（领域模型）：
  - 职责：聚合根与实体、领域方法、领域事件与工厂，实现业务不变式；不关心 Web/持久化细节。
  - 典型位置：`only-danmuku-domain/src/main/kotlin/.../aggregates`、`.../_share/meta`（Schema/Specification）。
  - 所有可变字段均 `internal set`；通过领域方法执行业务变更与事件发布。

—

## API 编写规范（Controller）

- 目录与风格：位于 `only-danmuku-adapter/.../portal/api`，按业务拆分文件，统一 `@PostMapping` 风格。
- 职责：
  - 解析上下文（如登录用户），绑定 JSR-303 注解校验；
  - 调用 `Mediator.commands.send(...)` 或 `Mediator.queries.send(...)`；
  - 不写业务分支，不操作聚合，不访问仓储/事务。
- 入参：使用 `Request` DTO 或函数参数，必要时结合自定义校验器。
- 示例：`CompatibleVideoSeriesController.kt:214` 发起保存系列/视频操作；查询示例见 `GetVideoSeriesDetail`/`loadAllVideo`。

—

## 命令（Command）编写规范

- 目录：`only-danmuku-application/.../commands`。
- 原则：
  - 单命令只修改一个聚合根；跨聚合通过领域事件+额外命令解耦。
  - 命令依赖仓储/工厂，不依赖查询；禁止在命令中使用读端 `sqlClient`。
  - 被修改的聚合必须通过仓储重新加载，禁止使用入参传入的“非托管实体/快照”直接赋值。
  - 变更通过“领域方法”完成，禁止在命令中直接改字段。
  - 成功后调用 `Mediator.uow.save()` 提交。
- 典型流程：
  1) 分析命令，拆分“前置校验逻辑”与“核心领域变更”；
  2) 将命令与校验器作为“设计元素”写入 `design/*_gen.json`，执行 `./gradlew genDesign` 生成标准骨架；
  3) 在命令 Handler 中：使用仓储获取聚合 → 调用领域方法 → 视需要由领域方法内部触发领域事件 → `Mediator.uow.save()`。
- 校验策略：
  - 复杂的跨表/读端校验，用“校验器 + 查询”承担；校验器不依赖仓储，可依赖查询；若缺少查询，先在 design 定义查询再生成实现。
  - 业务错误统一抛出 `KnownException`。
- 示例：
  - “系列视频编辑”采用聚合方法 `replaceVideos` 变更顺序与集合，命令内不直接修改集合（见 `CustomerVideoSeries.kt:161`）。

—

## 领域边界与隔离补充

- 事件发布：只有聚合根可以发布领域事件；状态变更必须发生在聚合级别，遵循“整存整取”原则。
- 实体标识：命令、事件不得以子实体（非聚合根）ID 作为入参；查询可按 ID 查询（查询层独立于 DDD）。
- 命令操作：命令必须通过仓储对聚合进行整体加载与保存，禁止部分更新。
- 查询操作：查询不受“整存整取”约束，可直接利用数据库能力；查询层独立于 DDD，可按 ID 进行筛选。
- 防腐层职责：防腐层负责文件操作等非数据库交互，必须与数据库概念（如 ID）隔离。
- 命令隔离：命令中不得包含查询逻辑或直接调用防腐层。
- 防腐层隔离：防腐层不应包含任何数据库 ID 概念。

—

## 查询（Query）编写规范

- 契约：`only-danmuku-application/.../queries` 定义 Query 对象；
- 实现：`only-danmuku-adapter/.../application/queries` 实现 Handler，依赖 `KSqlClient`（Jimmer）而非仓储；
- 原则：
  - 查询只读，不修改聚合/外部状态；
  - 返回 DTO 或 `queries._share.model` 投影，避免返回聚合实体；
  - 在查询层完成过滤、分页、排序、拼装。
- 示例：
  - 分页查询草稿：`only-danmuku-adapter/src/main/kotlin/edu/only4/danmuku/adapter/application/queries/video_draft/GetUserVideoPostsQryHandler.kt:29`
  - 连接查询临时路径（SQL 等价于 `vfus left join vfp left join vp`）：`only-danmuku-adapter/src/main/kotlin/edu/only4/danmuku/adapter/application/queries/video_file_upload_session/GetUploadedTempPathsQryHandler.kt:20`

—

## 防腐层 Client（反向适配外部服务）

- 契约（application 层）：定义 `object XxxCli { class Request : RequestParam<Response>; class Response }`，位于 `.../application/distributed/clients`。
- Handler（adapter 层）：`class XxxCliHandler : RequestHandler<XxxCli.Request, XxxCli.Response>`，位于 `.../adapter/application/distributed/clients`，在 `exec` 中调用外部 SDK/HTTP 并返回结果；不承载领域逻辑。
- 生成：在 `design/*_gen.json` 中声明 `client` 设计元素，执行 `./gradlew genDesign`，将同时生成 Client 与 Handler 骨架（已对齐 `CaptchaGenCli`/`CaptchaGenCliHandler` 样式）。
- 示例：
  - 契约：`only-danmuku-application/src/main/kotlin/edu/only4/danmuku/application/distributed/clients/CaptchaGenCli.kt:1`
  - Handler：`only-danmuku-adapter/src/main/kotlin/edu/only4/danmuku/adapter/application/distributed/clients/CaptchaGenCliHandler.kt:1`

—

## 聚合与领域方法编写规范

- 字段可见性：聚合/实体的可变字段统一 `internal set`；禁止在命令中直接赋值。
- 领域方法：将状态变更、约束检查、事件触发封装为领域方法（如 `replaceVideos`、`removeVideo`）。
- 事件触发：在领域方法内部按需触发领域事件（监听器有行为时才发），保持“状态变更”和“事件语义”一致。
- 生命周期：支持 `onCreate`/`onUpdate`/`onDelete` 生命周期方法，由框架回调，禁止业务代码手动调用。
- 示例：`only-danmuku-domain/src/main/kotlin/edu/only4/danmuku/domain/aggregates/customer_video_series/CustomerVideoSeries.kt:161`

—

## 领域事件与订阅

- 命名规范：`实体 + 过去式动作`，如 `VideoPostTranscodingRequiredDomainEvent`；
- 定义缺失时：将事件作为设计元素写入 design，执行 `./gradlew genDesign` 生成事件与订阅骨架；
- 订阅实现：监听器内职责与 API 一致，做编排与触发命令；同一事件若触发多个动作，请拆为多个监听方法（尽量一对一）。
- 示例：`only-danmuku-application/src/main/kotlin/edu/only4/danmuku/application/subscribers/domain/video_draft/VideoPostTranscodingRequiredDomainEventSubscriber.kt:1`

—

## 校验器编写规范

- 位置：`only-danmuku-application/.../validater`；
- 原则：
  - 校验器不依赖仓储，可依赖查询；缺查询时先在 design 定义查询并生成；
  - 与命令配合，在控制层和命令前尽早失败；
  - 统一抛 `KnownException` 或返回标准约束违例。

—

## 代码生成与设计文件

- 设计文件：位于 `only-danmuku/design/*_gen.json`，支持标签别名（如 `cmd/command`、`qry/query`、`cli/client` 等）。
- 生成命令：执行 `./gradlew genDesign`（插件会自动依赖 domain 的 `kspKotlin`，以便按 KSP 元数据定位聚合）。
- 生成范围：命令/查询/领域事件/校验器/防腐层 Client 契约与 Handler 的标准骨架。

—

## 其他通用约定

- CQRS 严格划分：命令不依赖查询，查询不依赖仓储；
- 异常：业务异常统一 `KnownException`；
- 日志：仅对关键行为打点（如转码、外部调用），包含关键标识（videoId、uploadId 等）；
- 配置：路径、阈值使用配置类，避免硬编码；
- 规模限制：列表/数量等限制在命令或聚合内统一收敛（例如系列视频数量不超过 `Byte.MAX_VALUE`）。

以上规约与现有代码保持一致，若新增场景（如缺少查询/事件/Client），请优先在 design 中补充设计元素并通过 `genDesign` 生成标准骨架，再落实现有代码。

